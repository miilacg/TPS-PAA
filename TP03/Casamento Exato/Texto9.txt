4 Desenvolvimento do programa
4.1 Parte A
4.1.1 Arquivo "partea.h"
Nesse arquivo foi feita a definicao do "modoDebug", a implementacao das estruturas de dados utilizadas e o escopo das funcoes que foram implementadas. O "modoDebug" e uma variavel definida no inicio do programa e utilizada para configurar se o programa ira executar em modo de analise ou nao. Ela foi definido como 1 e sera comparada com a opcao escolhida pelo usuario. Caso as duas sejam iguais, o programa sera executado com o modo analise ativado e ira retornar para o usuario o numero total de chamadas recursivas (no caso da recursao e do memoization) que foram feitas para chegar no resultado, tempo total gasto, memoria utilizada para soma, entre outras informacoes. Alem disso, tambem sera apresentado a maior soma encontrada e a rota seguida - essa ultima parte tambem e informado quando o modoanalise nao esta ativo. As estruturas criadas e usadas no programa podem ser vistas no algoritmo 1 apresentado abaixo. A estrutura "Piramide" foi usada para guardar as informacoes sobre a piramide. Nela foram salvos os dados lidos no arquivo ("**espaco"), a altura que a piramide tem ("qtdLinhas") e uma matriz utilizada para mostrar a rota ("**caminhoPercorrido"). Tambem foi necessaria a criacao da estrutura "Analise" que tem as variaveis que usadas para guardar as informacoes  que  seriam  retornadas para os usuarios.
4.1.2 Arquivo "parte.c"
4.1.2.1  Funcao "piramideRecursiva();"
A funcao "piramideRecursiva();" e a responsavel por resolver o problema de forma recursiva. Ela faz uso de chamadas recursivas para fazer a soma dos numeros. Nessa funcao foram utilizadas as variaveis "baixo" e "direita" para auxiliar na resolucao do problema. Pela configuracao que a piramide era lida o movimento para esquerda foi feito para baixo, dessa forma a variavel "baixo" recebia o retorno da chamada recursiva para o numero logo abaixo do posicao que estava no momento e a variavel "direita" recebia o retorno da chamada para a posicao diagonalmente a direita. Depois disso era feita a comparacao entre as duas variaveis e retornado o valor da maior somado ao valor do numero que esta naquela posicao da piramide. A funcao salva o valor retornado em uma variavel auxiliar ("caminho[][]") para que a funcao "caminhoPercorrido();" possa utilizar. Logo abaixo esta o codigo que executa exatamente o que foi supracitado. 
4.1.2.2 Funcao "piramideMemoization();"
A funcao "piramideMemoization();" tambem foi desenvolvida para chegar no resultado usando recursao, mas ela analisa antes se o calculo ja foi feito para nao ter retrabalho. Para isso, foi utilizada a matriz "caminho[][]" que salva os valores ja calculados. A matriz e inicializada com 0, entao o programa verifica se o valor naquela posicao e 0, caso seja, a conta sera feita. Essa matriz tambem e utilizada na hora de informar a rota seguida. Com excecao a essa comparacao, a funcao "piramideMemoization();" funciona da mesma forma que a funcao "piramideRecursiva();" explicada anteriormente. O codigo 3 mostra a parte da implementacao que e diferente da "piramideRecursiva();"
4.1.2.3 Funcao "piramideIterativa();"
Essa funcao e utilizada para implementar a versao que resolve o problema "de tras pra frente", ou seja, ela comeca da base da piramide e vai subindo ate o topo dividindo o problema maior em problemas menores para tentar encontrar a solucao com um melhor desempenho. Alem de dividir o problema em pedacos menores, ela tambem utiliza uma tabela para controlar quais solucoes ela ja havia encontrado. Nessa funcao, diferente das outras, nao e utilizada recursividade,  elaresolve o problema de forma iterativa.  No inicio da funcao, a matriz auxiliar ('caminho[][]') recebe os valores da piramide original e ela e utilizada na resolucao do problema. Ao inves das variaveis 'baixo' e 'direita' receberem o retorno de uma chamada recursiva, elas recebem o valor de posicoes da matriz auxiliar e faz a comparacao entre eles. A matriz auxiliar entao recebe, na posicao indicada, o valor dela acrescido do maior valor encontrado atraves da comparacao entre 'baixo' e 'direita'. O codigo dessa funcao pode ser visto na implementacao.
4.1.2.4 Funcao 'solucao();'
Essa funcao tem como principal objetivo dar inicio a aplicacao, sendo assim responsavel por  inicializar as variaveis da analise, a matriz auxiliar 'caminho[][]' e chamar as funcoes que irao encontrar a soma e informar a rota de acordo com a implementacao que o usuario deseja. E nessa funcao que e feita a escolha de qual funcao de soma sera chamada de acordo com a escolha do usuario. Caso o usuario passe como opcao o numero "1" a funcao chamada e a recursiva, caso a opcao digitada for "2" a funcao memoization e chamada e se for "3" sera utilizada a funcao iterativa. Nessa funcao tambem e feita a comparacao entre o modo de operacao escolhido pelo usuario e o 'modoDebug' e a impressao do caminho percorrido. No codigo 5 pode ser visto parte dessa funcao.
4.1.2.5 Funcao 'geraPiramide();'
Tambem foi feita a implementacao de uma funcao extra que permiti ao usuario criar novas piramides. Essa funcao recebe como parametro o tamanho da piramide, um numero e um contador. O numero e utilizado para criar nomes diferentes para cada arquivo e o contador e utilizado para contar quantas piramides foram criadas e poder avisar ao usuario quando todas estiverem prontas. O tamanho e os numeros inseridos na piramide sao gerados aleatoriamente. Os tamanhos da piramide variam entre 1 e 100 e os valores contidos nela variam entre 0 e 100. Essa funcao e chamada pelo 'main.c' de acordo com o numero de piramides que o usuario desejou criar. Ela foi utilizada para criar as piramides utilizadas em alguns dos testes.
4.1.2.6 Funcao 'caminhoPercorrido();'
Nessa funcao e inicializada a matriz 'caminhoPercorrido[][]' com 0 em todas as posicoes. A mesma e utilizada na hora de informar a rota que foi seguida. Para descobrir o caminho percorrido foi feita a comparacao entre duas posicoes da matriz auxiliar 'caminho[][]', fornecida pelas funcoes de soma. O indice da posicao que tiver o maior valor nessa comparacao e utilizado para que a matriz 'caminhoPercorrido[][]', na posicao desse indice, receba 1. O codigo 6 mostra a implementacao dessa funcao.
4.1.2.7 Funcoes para testes automaticos.
Foram criadas 2 novas funcoes que sao capazes de realizar testes automaticamente recebendo do cliente apenas a quantidade de testes que ele deseja realizar. A funcao 'teste();' e a responsavel por dar inicio aos testes. Nela tem a implementacao de um for que executa a quantidade de vez que o cliente desejou fazer os testes. Dentro desse for, uma variavel recebe um numero aleatorio entre 1 e 39 para ser o tamanho da piramide (dessa forma, caso o usuario queria fazer esse tipo de teste, as piramides terao 39 como altura maxima), depois disso a  fuņcao que gera piramides e invocada. A seguir e utilizado ums printf para salvar o nome do arquivo criado na variavel 'nomeArquivo'. Dentro do for principal foi criado um novo for para chamar a funcao 'solucaoTeste();' uma vez para cada um dos modos implementado. essa funcao tem o mesmo principio de funcionamento da 'solucao();', mudando apenas o modo como as informacoes sao mostradas na tela. O retorno dos testes automatizados pode ser visto na figura 3. 
4.1.2.8 Outras funcoes
Foram criadas as funcoes 'alocaEspaco();', 'lerArquivo();', 'contaLinhas();', 'tempoInicial();' e 'tempoFinalizado()'. A funcao 'alocaEspaco();' e utilizada para alocar um espaco de memoria para a piramide de acordo com o que foi lido na arquivo usando a funcao 'lerArquivo();'. A funcao 'contaLinhas()', e necessaria para saber qual altura (quantidadede linhas) da piramide. Por ultimo, as funcoes 'tempoInicial();' e 'tempoFi-nalizado();’ sao utilizadas para saber qual o tempo utilizado para encontrara maior soma e para mostrar a rota seguida.
4.1.3 Arquivo 'main.c'
Nesse arquivo foram feitos os menus utilizados pelos usuarios. No primeiro menu, visto na figura 4, o usuario pode escolher entre "carregar um arquivo de dados", "criar piramides aleatorias", "fazer testes automaticos", "voltar" e "sair do programa". Caso o usuario escolha a primeira opcao, ele sera levado a um outro menu (figura 5) onde escolhera qual metodo ele deseja para encontrar a maior soma. Ao escolher o metodo, ele devera entrar com o nome do arquivo de onde sera feita a leitura da piramide. Nesse menu o usuario tambem tem as opcoes de sair do programa ou voltar para o menu anterior. Depois de escolher o metodo e inserir o nome do arquivo, o usuario escolhera se deseja ou nao ativar o 'modoDebug'. A opcao "2" permite ao usuario criar um ou mais arquivos de testes com piramides  de  tamanhos  e  valores  escolhidos  aleatoriamente. Na terceira opcao o usuario pode fazer testes automaticamente passando para o programa a quantidade de vezes que ele deseja realizar os mesmos. Por fim, a opcao "5" termina o programa. Quando o usuario escolhe a opcao de criar novas piramides ou a opcao de fazer testes automaticamente e informado que, caso ele ja tenha arquivos com os nomes dos arquivos que serao criados, ele perdera os arquivos. Em seguida, o programa confirma se o usuario quer prosseguir mesmo assim.
4.2 Parte B
4.2.1 Arquivo 'DistanciaEdicao.h'
Nesse arquivo foi desenvolvido a estrutura 'MatrizDistancia' que tem como objetivo armazenar a matriz, o custo e  as operacoes gerados pelo problema. Alem da estrutura e bom ressaltar que tambem esta incluso nesse arquivo o cabecalho das funcoes a serem desenvolvidas no arquivo '.c'.
4.2.2 Arquivo 'DistanciaEdicao.c'
Esse arquivo contem a parte principal do algoritmo, nele esta implementado todas as funcoes responsaveis por gerar o problema e resolve-lo.
4.2.2.1 Funcao 'InicializaMatrizDistancia()'.
A funcao 'InicializaMatrizDistancia();' (codigo 8) e responsavel por alocar dinamicamente um espaco na memoria para uma matriz numero detamanho MxN, onde M e o tamanho da primeira palavra e N o tamanho da segunda palavra. Essa matriz 'Numero[][]' armazena o menor numero obtido pela funcao 'Minimo();' (codigo 9) que sera explicada posteriormente. Alem da alocacao da matriz numero, tambem e alocado a matriz e custo, responsavel por armazenar o custo de cada operacao, sendo esse custo limitado a '0' e '1', e a matriz operacao, que armazena qual operacao sera realizada no momento. Logo abaixo esta o codigo que executa exatamente o que foi supracitado.
4.2.2.2 Funcao 'Minimo();'
Essa funcao apesar de simples e uma das mais importantes do algoritmo, pois ela e responsavel por retornar para a fuņcao 'distancia();' (codigo 10) qual o menor numero a ser armazenado na matriz no momento.  Al ́em dessafuncionalidade ela utiliza de uma variavel global 'aux' do tipo inteiro, que de acordo com o comando de repeticao a executar, dita qual operacao sera armazenada no momento. Essa variavel 'aux' recebe os valores, 2, 3 e 4, onde 2 representa a operacao deletar, 3 representa a operacao inserir e 3 representa a operacao substituir. Logo abaixo esta o codigo que executa exatamente o que foi supracitado.    
4.2.2.3 Funcao 'Distancia();'
A funcao Distancia() (Codigo 10) e responsavel por retornar o tamanho da menor distancia entre  as  palavras, ou seja, a funcao principal do algoritmo. Como exemplificado dentro de sala, ela pode ser implementadatanto recursivamente quanto iterativamente, as duas maneiras geram uma matriz MxN com os numeros minimos obtidos da funcao 'Minimo();' (codigo9) e atraves deles de "traz para frente" retorna a menor distancia entre as palavras. Obs: como foi requisitado na documentacao do trabalho, essa funcao segue de acordo como mostrado nos slides, onde a primeira operacao a tentar ser executada e a de delete, a segunda de insercao e a terceira de substituicao. Logo abaixo esta o c ́odigo que executa exatamente o que foi supracitado.
4.2.2.4 Funcao 'CalculaOperacoes();'
A funcao 'CalculaOperacoes();' (codigo 12) e responsavel por percorrera matriz gerada de traz para frente e de acordo com a operacao presente na posicao atual, realiza a movimentacao na matriz ate chegar ao seu fim, que no caso e a posicao 'i' igual a 0 e 'j' igual a 0. A partir desse movimento essa funcao imprime quantas operacoes de cada tipo foram feitas, sendo esses tipos deletar, inserir, substituir e manter. Logo abaixo esta o codigo que executa exatamente o que foi supracitado e a figura 6 exemplifica o caminho tomado por cada operacao realizada. 
4.2.3 Arquivo 'main.c'
Nesse arquivo foram feitos as partes de interacao com o usuario, onde esta contido um menu em que o mesmo pode escolher executar o algoritmono  modo recursivo ou iterativo (figura 7). Alem da parte de interacao, o 'modoDebug'foi implementado no main, onde esse modo e responsavel por executar um conjunto predeterminado de palavras e apresentar o tempo de execucao utilizado para cada uma das duplas de palavras e a memoria utilizada, sendo entao esse modo utilizado como veıculo de comparacao para os testes. 
5 Testes
5.1 Parte A 
Os testes foram realizados em cima de 15 piramides diferentes. Desses testes, 10 foram feitos usando a opcao de teste automatizado e para piramides com altura inferior a 40 e 5 foram feitos manualmente apenas para os modos memoization e "de tras pra frente" utilizando entradas com tamanho maior que 39. A divisao na forma de realizar os teste foi necessaria, pois para valores de entrada maiores que 40, a 'piramideRecursiva()' demora muito tempo impossibilitando os testes. Para calcular o tempo utilizado na execucao do programa, foi utilizado as funcoes de tempo. A funcao que marcava o inicio da contagem do tempo foi inserida em dois lugares diferente: uma antes de chamar a funcao de soma (para contabilizar o tempo utilizado na soma) e uma antes de chamara funcao que retornaria a rota (pra saber o tempo utilizado nessa parte). A funcao que retorna o tempo final foi inserida ao final de cada uma dessas partes. Depois, uma variavel 'tempoTotal' recebia o valor da soma dessas duas partes para saber o tempo total utilizado em cada um dos modos. No caso dos testes automatizados, as funcoes tambem foram utilizadas para calcular o tempo necessario para imprimir a rota ja que ela foi impressa em apenas um modo e simulada para calculos nos outros. Para o calculo da memoria utilizada, usamos a funcao 'sizeof()' que retorna a quantidade de bytes usados em determinada parte do codigo. Consideramos as seguintes utilizacao de memoria para cada um dos modos:
• Modo recursivo: 
	Calculo da soma:  uma matriz para salvar a piramide utilizada e a pilha de recursao
	Mostrar a rota seguida: duas matrizes (uma auxiliar e uma para mostrar a rota de fato)
• Modo memoization:
	Calculo da soma: duas matriz (uma para guardar a piramide e outra para guardar os resultados dos subproblemas) e a pilha de recursao
	Mostrar a rota seguida: uma matriz
• Modo "de tras pra frente": 
	Calculo da soma: duas matriz (uma para guardar a piramide e outra para guardar os resultados dos subproblemas)
	Mostrar a rota seguida: uma matriz
O dois ultimos modos utilizaram apenas uma matriz para impressao da rota pois a funcao utilizava a tabela dos resultados como matriz auxiliar.
5.1.1 Resultados
Os resultados de cada teste foram inseridos em tabelas e depois foram gerados graficos referentes ao tempo e memoria totais utilizados em cada uma das implementacoes. Os graficos permitiram uma melhor comparacao entre os metodos. Algumas tabelas e os graficos gerados podem ser vistos a seguir. Todos os dados apresentados estao em mili segundos (para tempo) e em bytes (para memoria). Na figura 9 e nos graficos 10 e 11 pode ser visto os resultados obtidos nas tres implementacoes para entradas menores que 39. Os graficos foram gerados com os dados dessas tabelas e foi utilizada a escala logarıtmica no eixo vertical para que os dados fossem vistos de forma mais clara.
Observando as tabelas e os graficos acima verificamos, como visto em sala de aula, que qualquer algoritmo resolve o problema em um bom tempo quando a entrada e pequena. Verificou-se tambem que a cada aumento no tamanho da entrada a diferenca de desempenho entre os metodos ia aumentando ate chegar em um determinado valor de entrada em que o uso da implementacao recursiva ja nao conseguia retornar a resposta em um tempo razoavel. Notou-se ainda que o crescimento de tempo e memoria e exponencial, no metodo recursivo, em relacao ao tamanho da entrada o que nao acontece nas outras implementacoes. Os graficos 12 e 13 mostram a comparacao entre os metodos memoization e iterativo para valores de entrada maior que 39 para tempo e memoria utilizados, respectivamente.
Para os dados analisados, nao existe uma grande diferenca de desempenho entre as duas implementacoes, mas o metodo Iterativo se mostrou mais eficaz para entradas entre 80 e 100. Pode-se inferir que, provavelmente, esse metodo tambem tera um melhor desempenho para valores de entrada maiores que 100 e que o desempenho dele se mostrara bem melhor que o memoization para valores de entrada muito grandes. Durante os testes, percebeu-se que o tempo utilizado variava muito dependendo  da  quantidade de coisas que o computador estava fazendo ao mesmo tempo.
Segundo os testes realizados podemos concluir que para palavras muito pequenas a pequenas variacoes nos resultados, porem para palavras muito grandes o algoritmo iterativo se mostrou mais eficaz que o recursivo.
5.2.2 Modo Usuario
O modo usuario (figura 16) permite com que seja lido duas entradas do teclado e apos exibir na tela o resultado da menor distancia entre as palavras, a quantidade de operacoes do tipo deletar realizadas, a quantidade de operacoes do tipo inserir, a quantidade de operacoes do tipo substituir, a quantidade de operacoes do tipo manter e a matriz gerada pelo algoritmo. Logo abaixo esta ilustrado os resultados obtidos apos receber as entradas do teclado 'bufalo' e 'willianbil'.
6 Conclusao
Utilizando as tecnicas de programacao dinamica exibidas dentro de sala, foi possivel resolver os problemas propostos pela especificacao do trabalho. Os algoritmos produzidos para resolver o problema da piramide e o problemada distancia de edicao foram baseados na programacao dinamica e atraves deles foram realizado testes de desempenho. ́E importante ressaltar que nahora de executar alguns testes tanto na parte A quanto na parte B foram encontrados problemas de demora da execucao para alguns tamanhos de entrada, sendo assim nao foi possivel apresentar testes para essas entradas. Com o trabalho tambem podemos aumentar nossos conhecimentos acerca dos problemas apresentados, obtendo um maior conhecimento sobre a tecnica da programacao dinamica e foi possivel notar a divergencia na execucao para as funcoes recursivas e iterativas.